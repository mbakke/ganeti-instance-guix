#!/usr/bin/env bash

# Copyright (C) 2017, 2018, 2019, 2020, 2022 Marius Bakke <marius@gnu.org>
# Copyright (C) 2022 David Larsson <david.larsson@selfhosted.xyz>
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <https://www.gnu.org/licenses/>.

# cancel script on error
set -e
shopt -s globstar

. ./common.sh

export LANG=en_US.utf8

TEMPDIR=$(mktemp -d /tmp/mnt_XXXXXX)
CLEANUP+=("rmdir $TEMPDIR")

# This is the root filesystem mount-point for guix.
TARGET_ROOT="$TEMPDIR"

guix_setup(){
    # Prepare the time machine if relevant.
    if [ -n "$OSP_COMMIT" ] || [ -n "$OSP_BRANCH" ] || [ -n "$OSP_REPO_URI" ]; then
        GUIX="$GUIX time-machine"
        if [ -n "$OSP_REPO_URI" ]; then
            GUIX="$GUIX --url=$OSP_REPO_URI"
        fi
        if [ -n "$OSP_COMMIT" ]; then
            GUIX="$GUIX --commit=$OSP_COMMIT"
        fi
        if [ -n "$OSP_BRANCH" ]; then
            GUIX="$GUIX --branch=$OSP_BRANCH"
        fi
        if [ -n "$OSP_DISABLE_AUTHENTICATION" ]; then
            GUIX="$GUIX --disable-authentication"
        fi
        log "Invoking time machine with the following parameters:"
        log "    $(echo $GUIX | cut --complement -f1,2 -d' ')"
        GUIX="$GUIX -- "
    fi

    GUIX="$GUIX system"

    if [ -n "$OSP_SYSTEM" ]; then
        GUIX="$GUIX --system=$OSP_SYSTEM"
    fi
    if [ -n "$OSP_TARGET" ]; then
        GUIX="$GUIX --target=$OSP_TARGET"
    fi
    echo "$GUIX"
}

# $1 like: /dev/mapper/vg--drbd-e7deba31--7f30--4475--9ff3--2565f232f780.disk0
partition_disk(){
    local TARGET_DEVICE="$1"
    local LUKS_PASSPHRASE="$2"
    local SIZE_PART_2="$3"
    #set -x
    log Starting partitioning on "$TARGET_DEVICE"

    # If this is a reinstallation, the second partition may contain a
    # mounted filesystem that needs unmounted to proceed.  If part2 is
    # a luks partition, then find it's /dev/mapper/<part> path, and
    # ensure that is unmounted.
    mapfile -t Parts < <("${SFDISK}" --no-reread -d -J "$TARGET_DEVICE" | "${JQ}" -r ".partitiontable.partitions[].node?");
    if "${CRYPTSETUP}" isLuks "${Parts[1]}" &>/dev/null; then
        local TARGET_PART="/dev/mapper/$("${LSBLK}" --json "${Parts[1]}" | "${JQ}" -r '.blockdevices[].children[0].name?')"
    else
        local TARGET_PART="${Parts[1]}"
    fi

    # It has happened that some VM has kernel panicked due to first
    # sectors not being properly wiped, and writing some random stuff
    # there has solved it:
    head -c 3145728 /dev/urandom > "$TARGET_DEVICE"; sync

    # Create bios_grub partition and offset so it's easy to use either
    # of MBR or GPT or to switch between them.
    # https://www.gnu.org/software/grub/manual/grub/html_node/BIOS-installation.html#BIOS-installation
    # If part2 should have a size limit, then use that for the second partition.
    log Creating 2 partitions on "$TARGET_DEVICE"
    if [[ -n "${SIZE_PART_2}" ]]; then
        "${PARTED}" --script "$TARGET_DEVICE" \
               mklabel gpt \
               mkpart primary 1MiB 3MiB \
               mkpart primary "$SIZE_PART_2" \
               set 1 bios_grub on &>/dev/null
        [[ "$?" == 0 ]] || {
            log Failed to partition "$TARGET_DEVICE" with size "${SIZE_PART_2}" for the second partition
            return 1
        }
    else
        "${PARTED}" --script "$TARGET_DEVICE" \
               mklabel gpt \
               mkpart primary 1MiB 3MiB \
               mkpart primary 3MiB 100% \
               set 1 bios_grub on &>/dev/null
        [[ "$?" == 0 ]] || {
            log Failed to partition "$TARGET_DEVICE"
            return 1
        }
    fi
    log Done creating 2 partitions. Checking for LUKS.
    # If luks, then luks-encrypt the target partition
    local TARGET_PART_NEW
    TARGET_PART_NEW=$("${SFDISK}" --no-reread -d -J "$TARGET_DEVICE" | ${JQ} -r ".partitiontable.partitions[1].node")
    log TARGET_PART_NEW="$TARGET_PART_NEW"
    if [[ -n "${LUKS_PASSPHRASE}" ]]; then
        log LUKS passphrase is set. Starting LUKS formatting.
        if printf '%s' "$LUKS_PASSPHRASE" | "${CRYPTSETUP}" luksFormat --type=luks1 --key-file - "${TARGET_PART_NEW}" &>/dev/null; then
            log Successfully luksformatted "${TARGET_PART_NEW}"
        else
            log Failed to luksformat "${TARGET_PART_NEW}"
            return 1
        fi
        #if printf '%s' "$LUKS_PASSPHRASE" | "${CRYPTSETUP}" luksOpen --key-file - "${TARGET_PART_NEW}" test-system_mapped &>/dev/null; then
        if printf '%s' "$LUKS_PASSPHRASE" | "${CRYPTSETUP}" luksOpen --key-file - "${TARGET_PART_NEW}" "${TARGET_PART_NEW##*/}"_mapped &>/dev/null; then
            log Successfully mapped "${TARGET_PART_NEW}" to "${TARGET_PART_NEW##*/}"_mapped

            CLEANUP+=("${CRYPTSETUP} luksClose ${TARGET_PART_NEW##*/}")
        else
            log Failed to map "${TARGET_PART_NEW}" to "${TARGET_PART_NEW##*/}"_mapped
            return 1
        fi
    fi
}

# $1 like: /dev/mapper/vg--drbd-e7deba31--7f30--4475--9ff3--2565f232f780.disk0
# find_partition_path returns the second partition's filepath
find_partition_path(){
    local TARGET_DEVICE="$1"
    local part="$2"
    local mappedname

    # This is somewhat tricky.  kpartx partitions always end up in /etc/mapper,
    # but TARGET_DEVICE is typically one of:
    # * /dev/loopN (for files)
    # * /dev/drbdN
    # * /dev/vg/a-b-c-d.disk0
    # For the first two, the mapped device becomes e.g. /dev/mapper/drbdNpN.
    # For the latter, the mapped device becomes /dev/mapper/vg-a--b--c--d.disk0pN.

    mappedname="$("$KPARTX" -l "$TARGET_DEVICE" | awk '{ print $1 }' | grep -m 1 "p${part}$")"
    echo "/dev/mapper/${mappedname}"
}

# $1 like: /dev/mapper/vg--drbd-e7deba31--7f30--4475--9ff3--2565f232f780.disk0
create_filesystems(){
    local TARGET_DEVICE="$1"
    local TARGET_PARTITION="$2"
    local FS_TYPE="$3"
    local LAYOUT="$4"
    local SWAP_SPACE=4G

    # Find the second partitions filepaths':
    local TARGET_DEV_PART2
    TARGET_DEV_PART2=$(find_partition_path "$TARGET_DEVICE" 2)

    # Resolve the corresponding $MKFS_$FS_TYPE variable.
    eval MKFS_CMD=\$"MKFS_$(echo "$FS_TYPE" | tr '[:lower:]' '[:upper:]')"

    if [[ "$LAYOUT" == basic ]]; then
        case "$FS_TYPE" in
            f2fs)
                "${MKFS_CMD}" -l "${INSTANCE_NAME}-system" -f "$TARGET_DEV_PART2"
                ;;
            ext*)
                "${MKFS_CMD}" -L "${INSTANCE_NAME}-system" -F "$TARGET_DEV_PART2"
                ;;
            *)
                "${MKFS_CMD}" -L "${INSTANCE_NAME}-system" -f "$TARGET_DEV_PART2"
                ;;
        esac
    elif [[ "$FS_TYPE" == btrfs ]]; then
        command -v "${BTRFS}" || {
            log "btrfs requested but not installed"
            exit 1
        }
        log Creating btrfs filesystem on second partition of "$TARGET_DEVICE"
        "${MKFS_CMD}" -L "${INSTANCE_NAME}-system" -f "$TARGET_DEV_PART2" || {
            log Failed to mkfs.btrfs on "$TARGET_DEV_PART2"
            return 1
        }
        # For btrfs, create a "system-root" subvolume that holds the
        # root file system.
        local BTRFS_ROOT="${TARGET_ROOT}/system-root"

        # Mount and create root filesystem
        "$MOUNT" "$TARGET_DEV_PART2" "$TARGET_ROOT" || {
            log Failed to "$MOUNT" "$TARGET_DEV_PART2" onto "$TARGET_ROOT"
            return 1
        }
        "${BTRFS}" subvolume create "$BTRFS_ROOT"

        # Setup the SWAP subvolume
        "${BTRFS}" subvolume create "$BTRFS_ROOT/swap"

        # Setup the SWAP-file
        chmod 700 "$BTRFS_ROOT/swap"
        truncate -s 0 "$BTRFS_ROOT/swap/swapfile"
        "${CHATTR}" +C "$BTRFS_ROOT/swap/swapfile"
        "${BTRFS}" property set "$BTRFS_ROOT/swap" compression none
        "${FALLOCATE}" -l "$SWAP_SPACE" "$BTRFS_ROOT/swap/swapfile"
        chmod 600 "$BTRFS_ROOT/swap/swapfile"
        "${MKSWAP}" -f "$BTRFS_ROOT/swap/swapfile"

        # Setup additional subvolumes
        mkdir -p "$BTRFS_ROOT/gnu"
        mkdir -p "$BTRFS_ROOT/var"
        "${BTRFS}" subvolume create "$BTRFS_ROOT/gnu/store"
        "${BTRFS}" subvolume create "$BTRFS_ROOT/var/lib"
        "${BTRFS}" subvolume create "$BTRFS_ROOT/var/log"
        "${BTRFS}" subvolume create "$BTRFS_ROOT/home"
        "$UMOUNT" "$TARGET_ROOT"
    elif [[ "$LAYOUT" == "advanced" ]]; then
        # Assume LVM.
        command -v "${PVCREATE}" || {
            log "LVM requested but lvm2 is not available"
            exit 1
        }
        "${PARTED}" --script "$TARGET_DEVICE" \
               set 2 lvm on
        "${PVCREATE}" "$TARGET_DEV_PART2"
        "${VGCREATE}" "$INSTANCE_NAME"_vg01 "$TARGET_DEV_PART2"
        CLEANUP+=("${VGCHANGE} -an ${INSTANCE_NAME}_vg01")
        ROOT_SIZE='-l 10%VG'
        HOME_SIZE='-l 10%VG'
        GNU_STORE_SIZE='-l 45%VG'
        VAR_LOG_SIZE='-l 10%VG'
        VAR_LIB_SIZE='-l 20%VG'
        SWAP_SIZE='-l 100%FREE'
        "${LVCREATE}" --yes -n lv_root $ROOT_SIZE -W y "$INSTANCE_NAME"_vg01
        "${LVCREATE}" --yes -n lv_home $HOME_SIZE -W y "$INSTANCE_NAME"_vg01
        "${LVCREATE}" --yes -n lv_gnu_store $GNU_STORE_SIZE -W y "$INSTANCE_NAME"_vg01
        "${LVCREATE}" --yes -n lv_var_log $VAR_LOG_SIZE -W y "$INSTANCE_NAME"_vg01
        "${LVCREATE}" --yes -n lv_var_lib $VAR_LIB_SIZE -W y "$INSTANCE_NAME"_vg01
        "${LVCREATE}" --yes -n lv_swap $SWAP_SIZE -W y "$INSTANCE_NAME"_vg01
        # -f (force) is needed if reinstalling and previous
        # logical-volume also was a swap volume and still has that
        # signature, else mkswap command will wait for user
        # confirmation
        "${MKSWAP}" -f --label "$INSTANCE_NAME"-swap \
                    /dev/"$INSTANCE_NAME"_vg01/lv_swap
        log Creating "$FS_TYPE" filesystems on logical volumes \
            of "$INSTANCE_NAME"_vg01 of "$TARGET_DEV_PART2"
        for lv in lv_root lv_home lv_gnu_store lv_var_log lv_var_lib; do
            "$MKFS_CMD" "/dev/${INSTANCE_NAME}_vg01/${lv}" || {
                log Failed to mkfs."$FS_TYPE" on /dev/"${INSTANCE_NAME}_vg01/$lv"
                return 1
            }
        done
    else
        log "Unsupported filesystem type and/or layout combination:"
        log " FS_TYPE: $FS_TYPE LAYOUT: $LAYOUT"
        return 1
    fi
}

prep_init_mount_point(){
    local TARGET_DEVICE="$1"
    local TARGET_PARTITION="$2"
    local GUIX_CONFIG="$3"
    local FS_TYPE="$4"
    local LAYOUT="$5"
    log Initializing guix on second partition of "$TARGET_DEVICE" \
        using config "$GUIX_CONFIG"

    local TARGET_DEV_PART2="$TARGET_PARTITION"

    if [[ "$LAYOUT" == "basic" ]]; then
        # Basic layouts can just be mounted directly.
        "$MOUNT" "$TARGET_DEV_PART2" "$TARGET_ROOT"
        CLEANUP+=("$UMOUNT $TARGET_ROOT")
    else
        if [[ "$FS_TYPE" == "btrfs" ]]; then
            # The advanced btrfs layout uses a system-root subvolume.
            "$MOUNT" -o "subvol=system-root" "$TARGET_DEV_PART2" "$TARGET_ROOT"
            CLEANUP+=("$UMOUNT $TARGET_ROOT")
        else
            # The advanced layout for non-btrfs filesystems is setup with LVM
            log Mounting LVM logical volumes from "${INSTANCE_NAME}"_vg01 \
                of "$TARGET_DEV_PART2"
            "$MOUNT" "/dev/${INSTANCE_NAME}_vg01/lv_root" "$TARGET_ROOT"
            CLEANUP+=("$UMOUNT $TARGET_ROOT")
            for lv in lv_home lv_gnu_store lv_var_log lv_swap lv_var_lib; do
                lv="${lv#lv_}"
                mkdir -p "$TARGET_ROOT"/"${lv//_/\/}" >&2
                if [[ ! "$lv" == swap ]]; then
                    log running: "$MOUNT" "/dev/${INSTANCE_NAME}_vg01/lv_${lv}" \
                        "$TARGET_ROOT"/"${lv//_/\/}" >&2
                    "$MOUNT" "/dev/${INSTANCE_NAME}_vg01/lv_${lv}" \
                          "$TARGET_ROOT"/"${lv//_/\/}"
                    CLEANUP+=("$UMOUNT $TARGET_ROOT/${lv//_/\/}")
                fi
            done
        fi
    fi
}

# guix system init on a target device's second partition
initialize_guix(){
    local GUIX_CONFIG="$1"
    local TARGET_ROOT="$2"
    export TARGET_DEVICE="$3"
    export FS_TYPE="$4"
    local GUIX="$5"

    # Build the system configuration and save GC root.
    rm -f "$GC_ROOT"
    $GUIX build --fallback --no-grafts -r "$GC_ROOT" "$GUIX_CONFIG"

    # Install GuixSD
    $GUIX init "$GUIX_CONFIG" "$TARGET_ROOT" || {
        log Failed to guix system init "$GUIX_CONFIG" "$TARGET_ROOT"
        return 1
    }
}

main(){
    # for testing, run (replace value of TARGET_DEVICE etc. as needed):
    # INSTANCE_NAME=testinstance \
    # NIC_0_IP=1.2.3.4 \
    # NIC_0_NETWORK_SUBNET=1.2.3.4/24 \
    # NIC_0_NETWORK_GATEWAY=1.2.3.1 \
    # DISK_COUNT=1 \
    # DISK_0_PATH=/dev/mapper/vg--drbd-e7deba31--7f30--4475--9ff3--2565f232f780.disk0 \
    # OSP_LAYOUT=standard OSP_FILESYSTEM=xfs \
    # OSP_VARIANT_CONFIG=$(pwd)/examples/dynamic-lvm.scm \
    # ./create
    local DEFAULT_VARIANT_CONFIG="${EXAMPLEDIR}/dynamic.scm"
    local VARIANT_CONFIG="${VARIANT_CONFIG:-$DEFAULT_VARIANT_CONFIG}"
    log Running with options set to:
    log INSTANCE_NAME: "${INSTANCE_NAME}"
    log TARGET_DEVICE: "${TARGET_DEVICE}"
    log OSP_FILESYSTEM: "${OSP_FILESYSTEM:-ext4}"
    log OSP_LAYOUT: "${OSP_LAYOUT:-basic}"
    log VARIANT_CONFIG: "${VARIANT_CONFIG}"

    # Make Guix use the specified CACHE_DIR to store Guile and Git caches.
    if [[ -n "$CACHE_DIR" ]] && [[ ! -d "$CACHE_DIR" ]]; then
        mkdir -p "$CACHE_DIR"
    fi
    if [[ -n "$GCROOTSDIR" ]] && [[ ! -d "$GCROOTSDIR" ]]; then
        mkdir -p "$GCROOTSDIR"
    fi

    if [[ -n "$GCROOTSDIR" ]]; then
        local GC_ROOT="$GCROOTSDIR/$INSTANCE_NAME"
    fi
    if [[ -n "$CACHE_DIR" ]]; then
        export XDG_CACHE_HOME="$CACHE_DIR"
    fi

    # Check if TARGET_DEVICE is a real block device, and losetup it if
    # it isn't (for example when using a file disk):
    if [[ ! -b "$TARGET_DEVICE" ]]; then
        local TARGET_DEVICE_ORIG="$TARGET_DEVICE"
        if ! TARGET_DEVICE=$("${LOSETUP}" --show -f "$TARGET_DEVICE"); then
            log Failed to "${LOSETUP}" "$TARGET_DEVICE_ORIG"
            return 1
        fi
        CLEANUP+=("${LOSETUP} -d $TARGET_DEVICE")
    fi

    # Check OS parameters and set an appropriate $GUIX command that
    # will use guix time-machine if needed.
    local GUIX_COMMAND
    GUIX_COMMAND=$(guix_setup)
    log GUIX_COMMAND is: "$GUIX_COMMAND"

    # Say 'cheeese'.
    $GUIX_COMMAND --version

    # A basic 2 partitions setup.
    partition_disk "$TARGET_DEVICE" "${LUKS_PASSPHRASE}" "$PART_SIZE"
    local TARGET_PARTITION
    TARGET_PARTITION=$(find_partition_path "$TARGET_DEVICE" 2)
    if [[ -n "$LUKS_PASSPHRASE" ]]; then
        TARGET_PARTITION="${TARGET_PARTITION##*/}_mapped"
    fi
    log DONE PARTITIONING. TARGET_PARTITION set to "$TARGET_PARTITION"

    # Add partition mappings.
    "${KPARTX}" -a "$TARGET_DEVICE"
    CLEANUP+=("${KPARTX} -d $TARGET_DEVICE")

    # Each filesystem and layout option combination is handled in the
    # create_filesystems function. This will possibly setup lvm based
    # on the OSP options.
    create_filesystems "$TARGET_DEVICE" "$TARGET_PARTITION" "${OSP_FILESYSTEM:-ext4}" "${OSP_LAYOUT:-basic}"
    log DONE CREATING FILESYSTEMS

    # Prep the mount point to initialize guix
    mapfile -t Parts < <("${SFDISK}" --no-reread -d -J "$TARGET_DEVICE" | "${JQ}" -r ".partitiontable.partitions[].node?");
    export LUKS_UUID="$("${BLKID}" -s UUID -o value "${Parts[1]}")"
    export LVM_UUID="$("${BLKID}" -s UUID -o value "${TARGET_PARTITION}")"
    if [[ -n "$LUKS_PASSPHRASE" ]]; then
        log LUKS_UUID="$LUKS_UUID"
    fi
    if [[ "${OSP_LAYOUT}" == standard ]] && [[ ! "${FS_TYPE}" == btrfs ]]; then
        log LVM_UUID="$LVM_UUID"
    fi
    prep_init_mount_point "$TARGET_DEVICE" "$TARGET_PARTITION" "$VARIANT_CONFIG" "${OSP_FILESYSTEM:-ext4}" "${OSP_LAYOUT:-basic}" "${LUKS_UUID}"

    # Initialize/install Guix!
    log Guix will now be initialized on "$TARGET_ROOT"

    # The LVM_UUID variable is only needed when using luks. Since
    # TARGET_PARTITION will generally refer to
    # /dev/mapper/loop0p2_mapped if we are using luks, we need to find
    # the UUID of just the second partition of the TARGET_DEVICE
    initialize_guix "$VARIANT_CONFIG" "$TARGET_ROOT" "$TARGET_DEVICE" "${OSP_FILESYSTEM:-ext4}" "$GUIX_COMMAND"

    # Deactivate lvm if needed
    if "${VGCHANGE}" "$INSTANCE_NAME"_vg01 -an &>/dev/null; then
        log Successfully deactivated lvm volume group "$INSTANCE_NAME"_vg01
    else
        log Warning: failed to deactivate lvm volume group "$INSTANCE_NAME"_vg01
    fi
    # Close luks if needed (must have lvm deactivated)
    if [[ -n "$LUKS_PASSPHRASE" ]]; then
    #if "${CRYPTSETUP}" isLuks "$TARGET_PARTITION" &>/dev/null; then
        if "${CRYPTSETUP}" luksClose "${TARGET_PARTITION##*/}" &>/dev/null; then
            log Successfully closed luks mapping for "${TARGET_PARTITION##*/}"
        else
            log Failed to close luks mapping for "${TARGET_PARTITION##*/}"
            return 1
        fi
    fi
}

[[ "$1" == '--source-only' ]] || main "$@"

# Execute cleanups.
cleanup
trap - EXIT

exit 0
