#!/usr/bin/env bash

# Copyright (C) 2017, 2018, 2019, 2020, 2022 Marius Bakke <marius@gnu.org>
# Copyright (C) 2022 David Larsson <david.larsson@selfhosted.xyz>
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <https://www.gnu.org/licenses/>.

# cancel script on error
set -e
shopt -s globstar

. ./common.sh

export LANG=en_US.utf8

TEMPDIR=$(mktemp -d /tmp/mnt_XXXXXX)
CLEANUP+=("rmdir $TEMPDIR")

# This is the root filesystem mount-point for guix.
TARGET_ROOT="$TEMPDIR"

guix_setup(){
    # Prepare the time machine if relevant.
    if [ -n "$OSP_COMMIT" ] || [ -n "$OSP_BRANCH" ] || [ -n "$OSP_REPO_URI" ]; then
        GUIX="$GUIX time-machine"
        if [ -n "$OSP_REPO_URI" ]; then
            GUIX="$GUIX --url=$OSP_REPO_URI"
        fi
        if [ -n "$OSP_COMMIT" ]; then
            GUIX="$GUIX --commit=$OSP_COMMIT"
        fi
        if [ -n "$OSP_BRANCH" ]; then
            GUIX="$GUIX --branch=$OSP_BRANCH"
        fi
        if [ -n "$OSP_DISABLE_AUTHENTICATION" ]; then
            GUIX="$GUIX --disable-authentication"
        fi
        log "Invoking time machine with the following parameters:"
        log "    $(echo $GUIX | cut --complement -f1,2 -d' ')"
        GUIX="$GUIX -- "
    fi

    GUIX="$GUIX system"

    if [ -n "$OSP_SYSTEM" ]; then
        GUIX="$GUIX --system=$OSP_SYSTEM"
    fi
    if [ -n "$OSP_TARGET" ]; then
        GUIX="$GUIX --target=$OSP_TARGET"
    fi
    echo "$GUIX"
}

# $1 like: /dev/mapper/vg--drbd-e7deba31--7f30--4475--9ff3--2565f232f780.disk0
partition_disk(){
    local TARGET_DEVICE="$1"

    log Starting partitioning on "$TARGET_DEVICE"

    # It has happened that some VM has kernel panicked due to first
    # sectors not being properly wiped, and writing some random stuff
    # there has solved it:
    head -c 3145728 /dev/urandom > "$TARGET_DEVICE"; sync

    # Create bios_grub partition and offset so it's easy to use either
    # of MBR or GPT or to switch between them.
    # https://www.gnu.org/software/grub/manual/grub/html_node/BIOS-installation.html#BIOS-installation
    log Creating 2 partitions on "$TARGET_DEVICE"
    "${PARTED}" --script "$TARGET_DEVICE" \
    mklabel gpt \
    mkpart primary 1MiB 3MiB \
    mkpart primary 3MiB 100% \
    set 1 bios_grub on
    [[ "$?" == 0 ]] || {
        log Failed to partition "$TARGET_DEVICE"
        return 1
    }
}

# $1 like: /dev/mapper/vg--drbd-e7deba31--7f30--4475--9ff3--2565f232f780.disk0
# find_partition_path returns the second partition's filepath
find_partition_path(){
    local TARGET_DEVICE="$1"
    local part="$2"
    local mappedname

    # This is somewhat tricky.  kpartx partitions always end up in /etc/mapper,
    # but TARGET_DEVICE is typically one of:
    # * /dev/loopN (for files)
    # * /dev/drbdN
    # * /dev/vg/a-b-c-d.disk0
    # For the first two, the mapped device becomes e.g. /dev/mapper/drbdNpN.
    # For the latter, the mapped device becomes /dev/mapper/vg-a--b--c--d.disk0pN.

    mappedname="$("$KPARTX" -l "$TARGET_DEVICE" | awk '{ print $1 }' | grep -m 1 "p${part}$")"
    echo "/dev/mapper/${mappedname}"
}

# $1 like: /dev/mapper/vg--drbd-e7deba31--7f30--4475--9ff3--2565f232f780.disk0
create_filesystems(){
    local TARGET_DEVICE="$1"
    local FS_TYPE="$2"
    local LAYOUT="$3"
    local SWAP_SPACE=4G

    # Find the second partitions filepaths':
    local TARGET_DEV_PART2
    TARGET_DEV_PART2=$(find_partition_path "$TARGET_DEVICE" 2)

    # Resolve the corresponding $MKFS_$FS_TYPE variable.
    eval MKFS_CMD=\$"MKFS_$(echo "$FS_TYPE" | tr '[:lower:]' '[:upper:]')"

    if [[ "$LAYOUT" == basic ]]; then
        "${MKFS_CMD}" -L "${INSTANCE_NAME}-system" "$TARGET_DEV_PART2" || {
            log Failed to mkfs."$FS_TYPE" on "$TARGET_DEV_PART2"
            return 1
        }
    elif [[ "$FS_TYPE" == btrfs ]]; then
        command -v "${BTRFS}" || {
            log "btrfs requested but not installed"
            exit 1
        }
        log Creating btrfs filesystem on second partition of "$TARGET_DEVICE"
        "${MKFS_CMD}" -L "${INSTANCE_NAME}-system" -f "$TARGET_DEV_PART2" || {
            log Failed to mkfs.btrfs on "$TARGET_DEV_PART2"
            return 1
        }

        # For btrfs, create a "system-root" subvolume that holds the
        # root file system.
        local BTRFS_ROOT="${TARGET_ROOT}/system-root"

        # Mount and create root filesystem
        "$MOUNT" "$TARGET_DEV_PART2" "$TARGET_ROOT" || {
            log Failed to "$MOUNT" "$TARGET_DEV_PART2" onto "$TARGET_ROOT"
            return 1
        }
        "${BTRFS}" subvolume create "$BTRFS_ROOT"

        # Setup the SWAP subvolume
        "${BTRFS}" subvolume create "$BTRFS_ROOT/swap"

        # Setup the SWAP-file
        chmod 700 "$BTRFS_ROOT/swap"
        truncate -s 0 "$BTRFS_ROOT/swap/swapfile"
        "${CHATTR}" +C "$BTRFS_ROOT/swap/swapfile"
        "${BTRFS}" property set "$BTRFS_ROOT/swap" compression none
        "${FALLOCATE}" -l "$SWAP_SPACE" "$BTRFS_ROOT/swap/swapfile"
        chmod 600 "$BTRFS_ROOT/swap/swapfile"
        "${MKSWAP}" -f "$BTRFS_ROOT/swap/swapfile"

        # Setup additional subvolumes
        mkdir -p "$BTRFS_ROOT/gnu"
        mkdir -p "$BTRFS_ROOT/var"
        "${BTRFS}" subvolume create "$BTRFS_ROOT/gnu/store"
        "${BTRFS}" subvolume create "$BTRFS_ROOT/var/lib"
        "${BTRFS}" subvolume create "$BTRFS_ROOT/var/log"
        "${BTRFS}" subvolume create "$BTRFS_ROOT/home"
        "$UMOUNT" "$TARGET_ROOT"
    elif [[ "$LAYOUT" == standard ]]; then
        # Assume LVM.
        command -v "${PVCREATE}" || {
            log "LVM requested but lvm2 is not available"
            exit 1
        }
        "${PARTED}" --script "$TARGET_DEVICE" \
               set 2 lvm on
        "${PVCREATE}" "$TARGET_DEV_PART2"
        "${VGCREATE}" "$INSTANCE_NAME"_vg01 "$TARGET_DEV_PART2"
        CLEANUP+=("${VGCHANGE} -an ${INSTANCE_NAME}_vg01")
        ROOT_SIZE='-l 10%VG'
        HOME_SIZE='-l 10%VG'
        GNU_STORE_SIZE='-l 45%VG'
        VAR_LOG_SIZE='-l 10%VG'
        VAR_LIB_SIZE='-l 20%VG'
        SWAP_SIZE='-l 100%FREE'
        "${LVCREATE}" --yes -n lv_root $ROOT_SIZE -W y "$INSTANCE_NAME"_vg01
        "${LVCREATE}" --yes -n lv_home $HOME_SIZE -W y "$INSTANCE_NAME"_vg01
        "${LVCREATE}" --yes -n lv_gnu_store $GNU_STORE_SIZE -W y "$INSTANCE_NAME"_vg01
        "${LVCREATE}" --yes -n lv_var_log $VAR_LOG_SIZE -W y "$INSTANCE_NAME"_vg01
        "${LVCREATE}" --yes -n lv_var_lib $VAR_LIB_SIZE -W y "$INSTANCE_NAME"_vg01
        "${LVCREATE}" --yes -n lv_swap $SWAP_SIZE -W y "$INSTANCE_NAME"_vg01
        # -f (force) is needed if reinstalling and previous
        # logical-volume also was a swap volume and still has that
        # signature, else mkswap command will wait for user
        # confirmation
        "${MKSWAP}" -f --label "$INSTANCE_NAME"-swap \
                    /dev/"$INSTANCE_NAME"_vg01/lv_swap
        log Creating "$FS_TYPE" filesystems on logical volumes \
            of "$INSTANCE_NAME"_vg01 of "$TARGET_DEV_PART2"
        for lv in lv_root lv_home lv_gnu_store lv_var_log lv_var_lib; do
            "$MKFS_CMD" "/dev/${INSTANCE_NAME}_vg01/${lv}" || {
                log Failed to mkfs."$FS_TYPE" on /dev/"${INSTANCE_NAME}_vg01/$lv"
                return 1
            }
        done
    else
        log "Unsupported filesystem type and/or layout combination:"
        log " FS_TYPE: $FS_TYPE LAYOUT: $LAYOUT"
        return 1
    fi
}

prep_init_mount_point(){
    local TARGET_DEVICE="$1"
    local GUIX_CONFIG="$2"
    local FS_TYPE="$3"
    local LAYOUT="$4"
    log Initializing guix on second partition of "$TARGET_DEVICE" \
        using config "$GUIX_CONFIG"

    # Assume there's a partition 1 for boot and find the second
    # partition's filepath.
    local TARGET_DEV_PART2
    TARGET_DEV_PART2=$(find_partition_path "$TARGET_DEVICE" 2)

    if [[ "$LAYOUT" == "basic" ]]; then
        # Basic layouts can just be mounted directly.
        "$MOUNT" "$TARGET_DEV_PART2" "$TARGET_ROOT"
        CLEANUP+=("$UMOUNT $TARGET_ROOT")
    else
        if [[ "$FS_TYPE" == "btrfs" ]]; then
            # The standard btrfs layout uses a system-root subvolume.
            "$MOUNT" -o "subvol=system-root" "$TARGET_DEV_PART2" "$TARGET_ROOT"
            CLEANUP+=("$UMOUNT $TARGET_ROOT")
        else
            # The standard layout for non-btrfs filesystems is setup with LVM
            log Mounting LVM logical volumes from "${INSTANCE_NAME}"_vg01 \
                of "$TARGET_DEV_PART2"
            "$MOUNT" "/dev/${INSTANCE_NAME}_vg01/lv_root" "$TARGET_ROOT"
            CLEANUP+=("$UMOUNT $TARGET_ROOT")
            for lv in lv_home lv_gnu_store lv_var_log lv_swap lv_var_lib; do
                lv="${lv#lv_}"
                mkdir -p "$TARGET_ROOT"/"${lv//_/\/}" >&2
                if [[ ! "$lv" == swap ]]; then
                    log running: "$MOUNT" "/dev/${INSTANCE_NAME}_vg01/lv_${lv}" \
                        "$TARGET_ROOT"/"${lv//_/\/}" >&2
                    "$MOUNT" "/dev/${INSTANCE_NAME}_vg01/lv_${lv}" \
                          "$TARGET_ROOT"/"${lv//_/\/}"
                    CLEANUP+=("$UMOUNT $TARGET_ROOT/${lv//_/\/}")
                fi
            done
        fi
    fi
}

# guix system init on a target device's second partition
initialize_guix(){
    local GUIX_CONFIG="$1"
    local TARGET_ROOT="$2"
    export TARGET_DEVICE="$3"
    export FS_TYPE="$4"
    local GUIX="$5"

    # Build the system configuration and save GC root.
    rm -f "$GC_ROOT"
    $GUIX build --fallback --no-grafts -r "$GC_ROOT" "$GUIX_CONFIG"

    # Install GuixSD
    $GUIX init "$GUIX_CONFIG" "$TARGET_ROOT" || {
        log Failed to guix system init "$GUIX_CONFIG" "$TARGET_ROOT"
        return 1
    }
}

main(){
    # for testing, run (replace value of TARGET_DEVICE etc. as needed):
    # INSTANCE_NAME=testinstance \
    # NIC_0_IP=1.2.3.4 \
    # NIC_0_NETWORK_SUBNET=1.2.3.4/24 \
    # NIC_0_NETWORK_GATEWAY=1.2.3.1 \
    # TARGET_DEVICE=/dev/mapper/vg--drbd-e7deba31--7f30--4475--9ff3--2565f232f780.disk0 \
    # OSP_LAYOUT=standard OSP_FILESYSTEM=xfs \
    # OSP_VARIANT_CONFIG=$(pwd)/examples/dynamic-lvm.scm \
    # ./create
    local DEFAULT_VARIANT_CONFIG="${EXAMPLEDIR}/dynamic.scm"
    local VARIANT_CONFIG="${VARIANT_CONFIG:-$DEFAULT_VARIANT_CONFIG}"
    log Running with options set to:
    log TARGET_DEVICE: "${TARGET_DEVICE}"
    log OSP_FILESYSTEM: "${OSP_FILESYSTEM:-ext4}"
    log OSP_LAYOUT: "${OSP_LAYOUT:-basic}"
    log VARIANT_CONFIG: "${VARIANT_CONFIG}"

    # Make Guix use the specified CACHE_DIR to store Guile and Git caches.
    if [[ -n "$CACHE_DIR" ]] && [[ ! -d "$CACHE_DIR" ]]; then
        mkdir -p "$CACHE_DIR"
    fi
    if [[ -n "$GCROOTSDIR" ]] && [[ ! -d "$GCROOTSDIR" ]]; then
        mkdir -p "$GCROOTSDIR"
    fi

    if [[ -n "$GCROOTSDIR" ]]; then
        local GC_ROOT="$GCROOTSDIR/$INSTANCE_NAME"
    fi
    if [[ -n "$CACHE_DIR" ]]; then
        export XDG_CACHE_HOME="$CACHE_DIR"
    fi

    # Check if TARGET_DEVICE is a real block device, and losetup it if
    # it isn't (for example when using a file disk):
    if [[ ! -b "$TARGET_DEVICE" ]]; then
        local TARGET_DEVICE_ORIG="$TARGET_DEVICE"
        if ! TARGET_DEVICE=$("${LOSETUP}" --show -f "$TARGET_DEVICE"); then
            log Failed to "${LOSETUP}" "$TARGET_DEVICE_ORIG"
            return 1
        fi
        CLEANUP+=("${LOSETUP} -d $TARGET_DEVICE")
    fi

    # Check OS parameters and set an appropriate $GUIX command that
    # will use guix time-machine if needed.
    local GUIX_COMMAND
    GUIX_COMMAND=$(guix_setup)
    log GUIX_COMMAND is: "$GUIX_COMMAND"

    # Say 'cheeese'.
    $GUIX_COMMAND --version

    # A basic 2 partitions setup.
    partition_disk "$TARGET_DEVICE"

    # Add partition mappings.
    "${KPARTX}" -a "$TARGET_DEVICE"
    CLEANUP+=("${KPARTX} -d $TARGET_DEVICE")

    # Each filesystem and layout option combination is handled in the
    # create_filesystems function. This will possibly setup lvm based
    # on the OSP options.
    create_filesystems "$TARGET_DEVICE" "${OSP_FILESYSTEM:-ext4}" "${OSP_LAYOUT:-basic}"

    # Prep the mount point to initialize guix on and then initialize guix.
    prep_init_mount_point "$TARGET_DEVICE" "$VARIANT_CONFIG" "${OSP_FILESYSTEM:-ext4}" "${OSP_LAYOUT:-basic}"
    initialize_guix "$VARIANT_CONFIG" "$TARGET_ROOT" "$TARGET_DEVICE" "${OSP_FILESYSTEM:-ext4}" "$GUIX_COMMAND"
}

[[ "$1" == '--source-only' ]] || main "$@"

# Execute cleanups.
cleanup
trap - EXIT

exit 0
